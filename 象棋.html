<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <div class="wall">
        <div class="wintitle"></div>
    </div>
    <div class="wrap">
       
        <div item="black" class="qizi black" Index="0"  rule="车" row="1" line="1">
            <div >車</div>
        </div>
        <div item="black" class="qizi black" Index="1" row="1" line="2" rule="马">
            <div >馬</div>
        </div>
        <div item="black" class="qizi black" Index="2" row="1" line="3" rule="相">
            <div >象</div>
        </div>
        <div item="black" class="qizi black" Index="3" row="1" line="4" rule="士">
            <div >仕</div>
        </div>
        <div item="black" class="qizi black" Index="4" row="1" line="5" rule="帅" live="1">
            <div >帥</div>
        </div>
        <div item="black" class="qizi black" Index="5" row="1" line="6" rule="士">
            <div >仕</div>
        </div>
        <div item="black" class="qizi black" Index="6" row="1" line="7" rule="相">
            <div >象</div>
        </div>
        <div item="black" class="qizi black" Index="7" row="1" line="8" rule="马">
            <div>馬</div>
        </div>
        <div item="black" class="qizi black" Index="8" rule="车" row="1" line="9">
            <div >車</div>
        </div>
        <div item="black" class="qizi black" Index="9" row="3" line="2" rule="炮">
            <div >炮</div>
        </div>
        <div item="black" class="qizi black" Index="10" row="3" line="8" rule="炮">
            <div>炮</div>
        </div>
        <div item="black" class="qizi black" Index="11" row="4" line="1" rule="兵">
            <div >卒</div>
        </div>
        <div item="black" class="qizi black" Index="12" row="4" line="3" rule="兵">
            <div>卒</div>
        </div>
        <div item="black" class="qizi black" Index="13" row="4" line="5" rule="兵">
            <div>卒</div>
        </div>
        <div item="black" class="qizi black" Index="14" row="4" line="7" rule="兵">
            <div>卒</div>
        </div>
        <div item="black" class="qizi black" Index="15" row="4" line="9" rule="兵">
            <div>卒</div>
        </div>
        <div item="red" class="qizi red" Index="16" row="7" line="1" rule="兵">
            <div>兵</div>
        </div>
        <div item="red" class="qizi red" Index="17" row="7" line="3" rule="兵">
            <div>兵</div>
        </div>
        <div item="red" class="qizi red" Index="18" row="7" line="5" rule="兵">
            <div>兵</div>
        </div>
        <div item="red" class="qizi red" Index="19" row="7" line="7" rule="兵">
            <div>兵</div>
        </div>
        <div item="red" class="qizi red" Index="20" row="7" line="9" rule="兵">
            <div>兵</div>
        </div>
        <div item="red" class="qizi red" Index="21" row="8" line="2" rule="炮">
            <div>炮</div>
        </div>
        <div item="red" class="qizi red" Index="22" row="8" line="8" rule="炮">
            <div>炮</div>
        </div>   
        <div item="red" class="qizi red" Index="23" rule="车" row="10" line="1">
            <div>車</div>
        </div>
        <div item="red" class="qizi red" Index="24" row="10" line="2" rule="马">
            <div>馬</div>
        </div>
        <div item="red" class="qizi red" Index="25"  row="10" line="3"  rule="相">
            <div>相</div>
        </div>
        <div item="red" class="qizi red" Index="26"  row="10" line="4" rule="士">
            <div>士</div>
        </div>
        <div item="red" class="qizi red" Index="27"  row="10" line="5" rule="帅" live="2">
            <div>將</div>
        </div>
        <div item="red" class="qizi red" Index="28"  row="10" line="6" rule="士">
            <div>士</div>
        </div>
        <div item="red" class="qizi red" Index="29"  row="10" line="7"  rule="相"> 
            <div>相</div>
        </div>
        <div item="red" class="qizi red"  Index="30" row="10" line="8" rule="马">
            <div>馬</div>
        </div>
        <div item="red" class="qizi red" Index="31" rule="车"  row="10" line="9">
            <div>車</div>
        </div>
      
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="weizhi"></div>
        <div class="qipan">      
            </div>
        <div style="position: relative; top: 20px;left:28px;font-size: 18px;">
            开发者--李志强，如在使用过程中发现bug或者不合理的地方，可以联系作者进行修改
        </div>
    </div>
    <script>
        // 记录整个棋盘的行列坐标  10行  9列
let weizhiObj=[
    {row:1,line:1},{row:1,line:2},{row:1,line:3},{row:1,line:4},{row:1,line:5},{row:1,line:6},{row:1,line:7},{row:1,line:8},{row:1,line:9},
    {row:2,line:1},{row:2,line:2},{row:2,line:3},{row:2,line:4},{row:2,line:5},{row:2,line:6},{row:2,line:7},{row:2,line:8},{row:2,line:9},
    {row:3,line:1},{row:3,line:2},{row:3,line:3},{row:3,line:4},{row:3,line:5},{row:3,line:6},{row:3,line:7},{row:3,line:8},{row:3,line:9},
    {row:4,line:1},{row:4,line:2},{row:4,line:3},{row:4,line:4},{row:4,line:5},{row:4,line:6},{row:4,line:7},{row:4,line:8},{row:4,line:9},
    {row:5,line:1},{row:5,line:2},{row:5,line:3},{row:5,line:4},{row:5,line:5},{row:5,line:6},{row:5,line:7},{row:5,line:8},{row:5,line:9},
    {row:6,line:1},{row:6,line:2},{row:6,line:3},{row:6,line:4},{row:6,line:5},{row:6,line:6},{row:6,line:7},{row:6,line:8},{row:6,line:9},
    {row:7,line:1},{row:7,line:2},{row:7,line:3},{row:7,line:4},{row:7,line:5},{row:7,line:6},{row:7,line:7},{row:7,line:8},{row:7,line:9},
    {row:8,line:1},{row:8,line:2},{row:8,line:3},{row:8,line:4},{row:8,line:5},{row:8,line:6},{row:8,line:7},{row:8,line:8},{row:8,line:9},
    {row:9,line:1},{row:9,line:2},{row:9,line:3},{row:9,line:4},{row:9,line:5},{row:9,line:6},{row:9,line:7},{row:9,line:8},{row:9,line:9},
    {row:10,line:1},{row:10,line:2},{row:10,line:3},{row:10,line:4},{row:10,line:5},{row:10,line:6},{row:10,line:7},{row:10,line:8},{row:10,line:9},
  
]
let run="red"; // 哪方正在执行
let ele = "";
let arr=[];  //存放当前棋子可以走的位置
let qizi = document.getElementsByClassName("qizi");
let qipan = document.getElementsByClassName("weizhi");
let wall = document.getElementsByClassName("wall")[0];
let wintitle = document.getElementsByClassName("wintitle")[0];
// 当前棋盘上点击的行和列
let row,line;
// 棋子
for(let i=0; i<qizi.length; i++){
    // 初始分配棋子的位置
    qizi[i].style.top = (qizi[i].getAttribute("row")-1)*84+"px";
    qizi[i].style.left = (qizi[i].getAttribute("line")-1)*84+"px";
    // 点击棋子时
    againClickFn();
}
// 棋盘
for(let i=0; i<90; i++) {
    // 给棋盘上90个位置分配对应的行和列
    qipan[i].setAttribute("row",weizhiObj[i].row );
    qipan[i].setAttribute("line",weizhiObj[i].line );
    // 点击棋盘
    qipan[i].onclick = function(){
      // 获取点击的行列
      row= qipan[i].getAttribute("row");
      line= qipan[i].getAttribute("line");
      // 没吃子，移动  必须是在选中了棋子，且是当前执行方的棋子
      if(ele && ele.getAttribute("item")==run){
        Move(); 
       
      }
     
    }
}



// 以下全是封装的全局方法

// 让所有棋子缩放还原的方法
function sizeReduction(){
    for(let i=0; i<qizi.length; i++){
       qizi[i].style.transform = "scale(1)";
    }
}

// 每当有棋子被删除，重新分配点击事件的函数
function againClickFn(){
    for(let i=0; i<qizi.length; i++){
        // 点击棋子时
        qizi[i].onclick = function(){
          let index=i;    
          row= qizi[i].getAttribute("row");
          line= qizi[i].getAttribute("line");
          // 还原所有棋子的尺寸
          sizeReduction();
          // 选中的是正要走的一方的棋子，此时要进行棋子放大
          if(qizi[i].getAttribute("item")==run){
            // 已经有棋子被选中
            ele = qizi[i];
            qizi[i].style.transform = "scale(1.2)";
            // 根据不同的规则得出可以走的位置
            cheRule(qizi[i]);  // 车 
            paoRule(qizi[i]); //炮
            zuRule(qizi[i]); //兵
            shiRule(qizi[i]); // 士
            shuaiRule(qizi[i]); // 帅
            xiangRule(qizi[i]); // 相
            maRule(qizi[i]); //马
          }else{   // 选中的不是正要走的一方的棋子，此时要进行吃子的判断
            // 吃子
            cheKillEnemy(index);  // 车
            paoKillEnemy(index); //炮
            let live1=false
            let live2=false
            for(let i=0;i<qizi.length;i++){
                if(qizi[i].getAttribute("live")=="1"){
                    live1 = true
                }
            }
            for(let i=0;i<qizi.length;i++){
                if(qizi[i].getAttribute("live")=="2"){
                    live2 = true
                }
            }
            if(!live1){
                wall.style.display="block";
                wintitle.innerHTML="红方获胜"
                wintitle.style.color="red"
            }
            if(!live2){
                wall.style.display="block";
                wintitle.innerHTML="黑方获胜"
                wintitle.style.color="black"
            }
            ele="";
            // 吃子之后重新分配事件
            againClickFn();      
          }
          
        }
      }
}
// 车的走法规则
function cheRule(value){
    let allowArr=[];
    let noAllowArr=[]
    if(value.getAttribute("rule")=="车"){
        let row = value.getAttribute("row");
        let line = value.getAttribute("line");
        // 判断整个棋盘能走的位置
        for(let i=0; i<90; i++) {
            if(weizhiObj[i].row==row || weizhiObj[i].line==line){
                allowArr.push(weizhiObj[i])
            }
        }
        // 过滤掉已经存在棋子的位置
        for(let i=0; i<qizi.length; i++) {
           if(qizi[i].getAttribute("row")==value.getAttribute("row") || qizi[i].getAttribute("line")==value.getAttribute("line")){
             noAllowArr.push({row:parseFloat(qizi[i].getAttribute("row")) ,
             line:parseFloat(qizi[i].getAttribute("line")) ,
             item:qizi[i].getAttribute("item")
            })
           }
        }

        
        // 同行阻隔判断
        for(let i=0; i<noAllowArr.length; i++) {
            if(row==noAllowArr[i].row) {
                // 符合这个条件说明是同一行
                for(let j=0;j<allowArr.length;j++){
                    if(allowArr[j].line<noAllowArr[i].line && noAllowArr[i].line<line){
                        allowArr.splice(j,1);
                        j--;
                    }
                }
                for(let j=0;j<allowArr.length;j++){
                    if(allowArr[j].line>noAllowArr[i].line && noAllowArr[i].line>line){
                        allowArr.splice(j,1);
                        j--;
                    }
                }
            }
        }
        // 同列阻隔判断
        for(let i=0; i<noAllowArr.length; i++) {
            if(line==noAllowArr[i].line) {
                // 符合这个条件说明是同一列
                for(let j=0;j<allowArr.length;j++){
                    if(allowArr[j].row<noAllowArr[i].row && noAllowArr[i].row<row){
                        allowArr.splice(j,1);
                        j--;
                    }
                }
                for(let j=0;j<allowArr.length;j++){
                    if(allowArr[j].row>noAllowArr[i].row && noAllowArr[i].row>row){
                        allowArr.splice(j,1);
                        j--;
                    }
                  
                }
            }
        }
        // 将自己棋子的位置过滤掉
        for(let i=0; i<noAllowArr.length; i++) {
          for(let j=0;j<allowArr.length;j++){
                if(noAllowArr[i].row == allowArr[j].row && noAllowArr[i].line == allowArr[j].line && noAllowArr[i].item == run){
                    allowArr.splice(j,1);
                    j--;
                }  
          }        
        }
        arr=allowArr;         
    }
  
}
// 车,兵,士,帅,相,马的吃子判断
function cheKillEnemy(index){
    if( ele && (ele.getAttribute("rule")=="车" || ele.getAttribute("rule")=="兵" || ele.getAttribute("rule")=="士" || ele.getAttribute("rule")=="帅" || ele.getAttribute("rule")=="相"|| ele.getAttribute("rule")=="马")){
        for(let i=0; i<arr.length;i++){
            if(arr[i].row==row && arr[i].line==line){
              // 还原所有棋子的尺寸
              sizeReduction();
              ele.setAttribute("row", row);
              ele.setAttribute("line", line);
              ele.style.top = (arr[i].row-1)*84+"px";
              ele.style.left = (arr[i].line-1)*84+"px";
              qizi[index].remove();
              ele="";
                if(run=="red"){
                    run ="black";
                }else{
                    run = "red"
                }  
              break;
            }
        } 
    }
   
}
// 没吃子的移动
function Move(){
    for(let i=0; i<arr.length;i++){
        if(arr[i].row==row && arr[i].line==line){
            // 还原所有棋子的尺寸
            sizeReduction();
            ele.setAttribute("row", row);
            ele.setAttribute("line", line);
            ele.style.top = (arr[i].row-1)*84+"px";
            ele.style.left = (arr[i].line-1)*84+"px";
            ele="";
            if(run=="red"){
                run ="black";
            }else{
                run = "red"
            }  
        }
    }      
}
// 炮的走法规则
function paoRule(value){
    let allowArr=[];
    let noAllowArr=[]
    if(value.getAttribute("rule")=="炮"){
        let row = value.getAttribute("row");
        let line = value.getAttribute("line");
        // 判断整个棋盘能走的位置
        for(let i=0; i<90; i++) {
            if(weizhiObj[i].row==row || weizhiObj[i].line==line){
                allowArr.push(weizhiObj[i])
            }
        }
        // 找已经存在棋子的位置
        for(let i=0; i<qizi.length; i++) {
           if(qizi[i].getAttribute("row")==value.getAttribute("row") || qizi[i].getAttribute("line")==value.getAttribute("line")){
             noAllowArr.push({row:parseFloat(qizi[i].getAttribute("row")) ,
             line:parseFloat(qizi[i].getAttribute("line")) ,
             item:qizi[i].getAttribute("item")
            })
           }
        }

        
        // 同行阻隔判断
        for(let i=0; i<noAllowArr.length; i++) {
            if(row==noAllowArr[i].row) {
                // 符合这个条件说明是同一行
                for(let j=0;j<allowArr.length;j++){
                    if(allowArr[j].line<noAllowArr[i].line && noAllowArr[i].line<line){
                        allowArr.splice(j,1);
                        j--;
                    }
                }
                for(let j=0;j<allowArr.length;j++){
                    if(allowArr[j].line>noAllowArr[i].line && noAllowArr[i].line>line){
                        allowArr.splice(j,1);
                        j--;
                    }
                }
            }
        }
        // 同列阻隔判断
        for(let i=0; i<noAllowArr.length; i++) {
            if(line==noAllowArr[i].line) {
                // 符合这个条件说明是同一列
                for(let j=0;j<allowArr.length;j++){
                    if(allowArr[j].row<noAllowArr[i].row && noAllowArr[i].row<row){
                        allowArr.splice(j,1);
                        j--;
                    }
                }
                for(let j=0;j<allowArr.length;j++){
                    if(allowArr[j].row>noAllowArr[i].row && noAllowArr[i].row>row){
                        allowArr.splice(j,1);
                        j--;
                    }
                  
                }
            }
        }
        // 将有棋子的位置过滤掉
        for(let i=0; i<noAllowArr.length; i++) {
          for(let j=0;j<allowArr.length;j++){
                if(noAllowArr[i].row == allowArr[j].row && noAllowArr[i].line == allowArr[j].line){
                    allowArr.splice(j,1);
                    j--;
                }  
          }        
        }
        arr=allowArr;         
    }
   
}
// 炮的吃子判断
function paoKillEnemy(index){
    if( ele && ele.getAttribute("rule")=="炮"){
       enemy = qizi[index];
       // 炮上下移动
       if(ele && ele.getAttribute("line")== enemy.getAttribute("line")){
          // 要吃的棋子在上方
          if(ele && parseFloat(ele.getAttribute("row"))>parseFloat(enemy.getAttribute("row"))){
             let maxRow = parseFloat(ele.getAttribute("row")) ;
             let minROW = parseFloat(enemy.getAttribute("row"));
             let num=0
             for(let i=0; i<qizi.length;i++){
                 if(maxRow>qizi[i].getAttribute("row") && minROW<qizi[i].getAttribute("row")&&
                 qizi[i].getAttribute("line")==ele.getAttribute("line")){
                    num++;
                 }
             }
             if(num==1){
                // 还原所有棋子的尺寸
                sizeReduction();
                ele.setAttribute("row", row);
                ele.setAttribute("line", line);
                ele.style.top = (row-1)*84+"px";
                ele.style.left = (line-1)*84+"px";
                qizi[index].remove();
                ele="";
                if(run=="red"){
                    run ="black";
                }else{
                    run = "red"
                }  
             }
             
          }
          // 要吃的棋子在下方
          if(ele && parseFloat(ele.getAttribute("row")) <parseFloat(enemy.getAttribute("row"))){   
            let maxRow =parseFloat(enemy.getAttribute("row")); 
            let minROW =parseFloat(ele.getAttribute("row"));
            console.log(maxRow,minROW);
            let num=0;
            for(let i=0; i<qizi.length;i++){
                if(maxRow>qizi[i].getAttribute("row") && minROW<qizi[i].getAttribute("row")&&
                qizi[i].getAttribute("line")==ele.getAttribute("line")){
                   num++;
                }
            }
            if(num==1){
               // 还原所有棋子的尺寸
               sizeReduction();
               ele.setAttribute("row", row);
               ele.setAttribute("line", line);
               ele.style.top = (row-1)*84+"px";
               ele.style.left = (line-1)*84+"px";
               qizi[index].remove();
               ele="";
               if(run=="red"){
                   run ="black";
               }else{
                   run = "red"
               }  
            }
           
          }
       }
       // 炮左右移动
       if(ele && ele.getAttribute("row")== enemy.getAttribute("row")){
        // 要吃的棋子在左边
        if(ele && parseFloat(ele.getAttribute("line"))>parseFloat(enemy.getAttribute("line"))){
           let maxLine = parseFloat(ele.getAttribute("line")) ;
           let minLine = parseFloat(enemy.getAttribute("line"));
           let num=0
           for(let i=0; i<qizi.length;i++){
               if(maxLine>qizi[i].getAttribute("line") && minLine<qizi[i].getAttribute("line")&&
               qizi[i].getAttribute("row")==ele.getAttribute("row")){
                  num++;
               }
           }
           if(num==1){
              // 还原所有棋子的尺寸
              sizeReduction();
              ele.setAttribute("row", row);
              ele.setAttribute("line", line);
              ele.style.top = (row-1)*84+"px";
              ele.style.left = (line-1)*84+"px";
              qizi[index].remove();
              ele="";
              if(run=="red"){
                  run ="black";
              }else{
                  run = "red"
              }  
           }
           
        }
      
        // 要吃的棋子在右边
        if(ele && parseFloat(ele.getAttribute("line"))<parseFloat(enemy.getAttribute("line"))){
           let minLine = parseFloat(ele.getAttribute("line")) ;
           let maxLine = parseFloat(enemy.getAttribute("line"));
           let num=0
           for(let i=0; i<qizi.length;i++){
               if(maxLine>qizi[i].getAttribute("line") && minLine<qizi[i].getAttribute("line")&&
               qizi[i].getAttribute("row")==ele.getAttribute("row")){
                  num++;
               }
           }
           if(num==1){
              // 还原所有棋子的尺寸
              sizeReduction();
              ele.setAttribute("row", row);
              ele.setAttribute("line", line);
              ele.style.top = (row-1)*84+"px";
              ele.style.left = (line-1)*84+"px";
              qizi[index].remove();
              ele="";
              if(run=="red"){
                  run ="black";
              }else{
                  run = "red"
              }  
           }
           
        }
      
     }
      
       
    }
   
}
// 兵的走法规则
function zuRule(value){
   
    if( ele && ele.getAttribute("rule")=="兵"){
        arr=[] 
        if(value.getAttribute("item")=="red"){
            // 当兵没有过河只能前进
            if(value.getAttribute("row")>5){
                arr.push({row:value.getAttribute("row")-1,line:value.getAttribute("line")-0});
            }else{// 兵过河了，可以左右走
                arr.push({row:value.getAttribute("row")-1,line:value.getAttribute("line")-0});
                arr.push({row:value.getAttribute("row")-0,line:value.getAttribute("line")-1});
                arr.push({row:value.getAttribute("row")-0,line:value.getAttribute("line")-0+1});
            }
           
        }else{
            // 当兵没有过河只能前进
            if(value.getAttribute("row")<6){
                arr.push({row:value.getAttribute("row")-0+1,line:value.getAttribute("line")-0});
            }else{// 兵过河了，可以左右走
                arr.push({row:value.getAttribute("row")-0+1,line:value.getAttribute("line")-0});
                arr.push({row:value.getAttribute("row")-0,line:value.getAttribute("line")-1});
                arr.push({row:value.getAttribute("row")-0,line:value.getAttribute("line")-0+1});
            }
        }
        // 判断这些位置是否有己方棋子
        try {
            for(let i=0; i<qizi.length; i++){
                for(let j=0; j<arr.length; j++){
                    if(arr[j].row == parseFloat(qizi[i].getAttribute("row"))
                     && arr[j].line == parseFloat(qizi[i].getAttribute("line")) 
                     && qizi[i].getAttribute("item")==run){
                        arr.splice(j,1);
                        j--;
                    }
                }
            }
        } catch (error) {
          
        }
       
           
    }
}
// 士的走法规则
function shiRule(value){
    if( ele && ele.getAttribute("rule")=="士"){
        arr=[] 
        // 红方
        if(value.getAttribute("item")=="red"){
            if(parseFloat(value.getAttribute("row")) == 9){
                arr=[{row:8,line:4},{row:10,line:4},{row:10,line:6},{row:8,line:6}]
            }else{
                arr=[{row:9,line:5}]
            }
           
        }else{ // 黑方
            if(parseFloat(value.getAttribute("row")) == 2){
                arr=[{row:1,line:4},{row:3,line:4},{row:1,line:6},{row:3,line:6}]
            }else{
                arr=[{row:2,line:5}]
            }
        }
        // 判断这些位置是否有己方棋子
        try {
            for(let i=0; i<qizi.length; i++){
                for(let j=0; j<arr.length; j++){
                    if(arr[j].row == parseFloat(qizi[i].getAttribute("row"))
                    &&arr[j].line == parseFloat(qizi[i].getAttribute("line"))
                    &&qizi[i].getAttribute("item")==run){
                        arr.splice(j,1);
                        j--;
                    }
                }
            }   
        } catch (error) {
           
        }
      
          
    }
}
// 将的走法规则
function shuaiRule(value){
    if( ele && ele.getAttribute("rule")=="帅"){
        arr= [];
        let allow =[{row:value.getAttribute('row')-1,line:value.getAttribute('line')-0},{row:value.getAttribute('row')-0+1,line:value.getAttribute('line')-0},
            {row:value.getAttribute('row')-0,line:value.getAttribute('line')-1},{row:value.getAttribute('row')-0,line:value.getAttribute('line')-0+1}]
        // 红方
        if(value.getAttribute("item")=="red"){
          let nine=[{row:8,line:4},{row:8,line:5},{row:8,line:6},{row:9,line:4},{row:9,line:5},{row:9,line:6},{row:10,line:4},{row:10,line:5},{row:10,line:6}];
          for(let i=0; i<nine.length; i++){
            for(let j=0; j<allow.length; j++){
              if(nine[i].row == allow[j].row && nine[i].line == allow[j].line){
                  arr.push(allow[j])
              }
            } 
          }
           
        }else{ // 黑方
          let nine=[{row:3,line:4},{row:3,line:5},{row:3,line:6},{row:2,line:4},{row:2,line:5},{row:2,line:6},{row:1,line:4},{row:1,line:5},{row:1,line:6}];
          for(let i=0; i<nine.length; i++){
            for(let j=0; j<allow.length; j++){
              if(nine[i].row == allow[j].row && nine[i].line == allow[j].line){
                  arr.push(allow[j])
              }
            } 
          }
         
        }
        // 判断这些位置是否有己方棋子
        try {
            for(let i=0; i<qizi.length; i++){
                for(let j=0; j<arr.length; j++){
                    if(arr[j].row == parseFloat(qizi[i].getAttribute("row")) 
                    && arr[j].line == parseFloat(qizi[i].getAttribute("line")) 
                    && qizi[i].getAttribute("item")==run){
                        arr.splice(j,1);
                        j--;
                    }
                }
            }  
        } catch (error) {
           
        }
     
          
    }
}
// 相的走法规则
function xiangRule(value){
    if( ele && ele.getAttribute("rule")=="相"){
        arr= [];
        let allow =[{row:value.getAttribute('row')-0+2,line:value.getAttribute('line')-0-2},{row:value.getAttribute('row')-2,line:value.getAttribute('line')-2},
            {row:value.getAttribute('row')-0+2,line:value.getAttribute('line')-0+2},{row:value.getAttribute('row')-2,line:value.getAttribute('line')-0+2}]
        // 红方
        if(value.getAttribute("item")=="red"){
          let nine=[{row:6,line:3},{row:6,line:7},{row:8,line:1},{row:8,line:5},{row:8,line:9},{row:10,line:3},{row:10,line:7}];
          for(let i=0; i<nine.length; i++){
            for(let j=0; j<allow.length; j++){
              if(nine[i].row == allow[j].row && nine[i].line == allow[j].line){
                  arr.push(allow[j])
              }
            } 
          }
           
        }else{ // 黑方
          let nine=[{row:1,line:3},{row:1,line:7},{row:3,line:1},{row:3,line:5},{row:3,line:9},{row:5,line:3},{row:5,line:7}];
          for(let i=0; i<nine.length; i++){
            for(let j=0; j<allow.length; j++){
              if(nine[i].row == allow[j].row && nine[i].line == allow[j].line){
                  arr.push(allow[j])
              }
            } 
          }
         
        }
        // 判断这些位置是否有己方棋子
        try {
            for(let i=0; i<qizi.length; i++){
                for(let j=0; j<arr.length; j++){
                    if(arr[j].row == parseFloat(qizi[i].getAttribute("row")) 
                    && arr[j].line == parseFloat(qizi[i].getAttribute("line")) 
                    && qizi[i].getAttribute("item")==run){
                        arr.splice(j,1);
                        j--;
                    }
                }
            }  
        } catch (error) {
           
        }
        for(let i=0; i<arr.length; i++){
            let flag = false;
            let preventRow = (parseFloat(ele.getAttribute("row")) + arr[i].row) / 2;
            let preventLine = (parseFloat(ele.getAttribute("line")) + arr[i].line) / 2;
            for(let j=0; j<qizi.length;j++){
                if(qizi[j].getAttribute("row")==preventRow && qizi[j].getAttribute("line")==preventLine){
                    flag = true;
                }
            }
            if(flag){
                arr.splice(i,1);
                i--;
            }
        }
    }
}
// 马的走法规则
function maRule(value){
    if( ele && ele.getAttribute("rule")=="马"){
        arr=[
            {row:value.getAttribute("row")-0+2,line:value.getAttribute("line")-0+1,dir:{row:value.getAttribute("row")-0+1,line:value.getAttribute("line")-0}},
            {row:value.getAttribute("row")-0+1,line:value.getAttribute("line")-0+2,dir:{row:value.getAttribute("row")-0,line:value.getAttribute("line")-0+1}},
            {row:value.getAttribute("row")-0-1,line:value.getAttribute("line")-0+2,dir:{row:value.getAttribute("row")-0,line:value.getAttribute("line")-0+1}},
            {row:value.getAttribute("row")-0-2,line:value.getAttribute("line")-0+1,dir:{row:value.getAttribute("row")-1,line:value.getAttribute("line")-0}},
            {row:value.getAttribute("row")-0-2,line:value.getAttribute("line")-0-1,dir:{row:value.getAttribute("row")-1,line:value.getAttribute("line")-0}},
            {row:value.getAttribute("row")-0-1,line:value.getAttribute("line")-0-2,dir:{row:value.getAttribute("row")-0,line:value.getAttribute("line")-1}},
            {row:value.getAttribute("row")-0+1,line:value.getAttribute("line")-0-2,dir:{row:value.getAttribute("row")-0,line:value.getAttribute("line")-1}},
            {row:value.getAttribute("row")-0+2,line:value.getAttribute("line")-0-1,dir:{row:value.getAttribute("row")-0+1,line:value.getAttribute("line")-0}},
        ]
          // 判断这些位置是否有己方棋子
          for(let i=0; i<qizi.length; i++){
            for(let j=0; j<arr.length; j++){
                if(arr[j].row == parseFloat(qizi[i].getAttribute("row")) 
                && arr[j].line == parseFloat(qizi[i].getAttribute("line")) 
                && qizi[i].getAttribute("item")==run){
                    arr.splice(j,1);
                    j--;
                }
            }
          }
        try {
            // 存在阻隔的位置过滤
            for(let i=0; i<qizi.length; i++){
                for(let j=0; j<arr.length; j++){
                   if (arr[j].dir.row== parseFloat(qizi[i].getAttribute("row"))
                   && arr[j].dir.line== parseFloat(qizi[i].getAttribute("line"))){
                    arr.splice(j,1);
                    j--
                   }
                }
            }
        } catch (error) {
            
        }
        console.log(arr);
        
        
    }  
}

    </script>
</body>
</html>
<style>
    body{
        margin: 0px 0px;
        user-select: none;
    }
    .wrap{
        margin: auto;
        /* margin-top: 40px; */
        width: 764px;
        height: 848px;
        position: relative;
      
    }
    .qipan{
        top: 32px;
        left: 32px;
        width: 700px;
        height: 784px;
        background-image: url('http://m.qpic.cn/psc?/V10ZU5Lm1dF324/TmEUgtj9EK6.7V8ajmQrEOmmNBMgEwuZ5IthiIPDP*xiCNciQKBPr4MAwT5GsmAa.67JcNiRp4xPuiIrL*4CeMsz0fhza617sx7Z4p7y94c!/b&bo=vAIPAwAAAAADJ7A!&rf=viewer_4');
        position: relative;
        z-index: -5;
    }
    .weizhi{
        width: 84px;
        height: 84px;
        float: left;
    }
    .qizi{
        width: 84px;
        height: 84px;
        cursor: pointer;
        position: absolute;
        z-index: 2;
        transition:top 0.3s linear,left 0.3s linear;
    }
    .qizi div{
        width: 70px;
        height: 70px;
        border: 2px solid #bebebe;
        box-shadow: 0px 0px 2px #888888;
        background: rgba(216, 216, 216, 1);
        margin-left: 6px;
        margin-top: 6px;
        border-radius: 50%;
        text-align: center;
        line-height: 70px;
        font-size:30px;
    }
    .red{
        color: red;
    }
    .wintitle{
        position: fixed;
        left: 42%;
        top: 41%;
        height: 70px;
        width: 300px;
        text-align: center;
        border-radius: 30px;
        background: white;
        color: black;
        font-size: 40px;
        font-weight: bold;
        line-height: 70px;
    }
    .wall{
        width: 100%;
        height: 100%;
        position: fixed;
        z-index: 999;
        background: rgba(0,0,0,0.3);
        display: none;
    }
</style>
